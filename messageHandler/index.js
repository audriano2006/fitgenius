// messageHandler/index.js - FitGenius Backend Principal
const { OpenAI } = require("openai");

// Configuration OpenAI (compatible avec Azure)
const openAIClient = new OpenAI({
    apiKey: process.env.AZURE_OPENAI_KEY,
    baseURL: `${process.env.AZURE_OPENAI_ENDPOINT}/openai/deployments/${process.env.GPT35_DEPLOYMENT_NAME}`,
    defaultQuery: { 'api-version': '2024-02-01' },
    defaultHeaders: { 'api-key': process.env.AZURE_OPENAI_KEY }
});

// Configuration Azure OpenAI
const openAIClient = new OpenAIClient(
    process.env.AZURE_OPENAI_ENDPOINT,
    new AzureKeyCredential(process.env.AZURE_OPENAI_KEY)
);

// Configuration Cosmos DB - TEMPORAIREMENT D√âSACTIV√â
let cosmosClient = null;
let database, usersContainer, interactionsContainer;

// Initialiser Cosmos DB
async function initializeCosmosDB() {
    try {
        // TEMPORAIREMENT D√âSACTIV√â POUR TESTER
        console.log("‚ö†Ô∏è Cosmos DB temporairement d√©sactiv√© pour les tests");
        
        // On r√©activera plus tard avec:
        // const { CosmosClient } = require("@azure/cosmos");
        // cosmosClient = new CosmosClient(process.env.AZURE_COSMOSDB_URI);
        // database = cosmosClient.database("fitgenius");
        // etc...
        
    } catch (error) {
        console.error("‚ùå Erreur Cosmos DB:", error);
    }
}

// Initialiser au d√©marrage
initializeCosmosDB();

// FONCTION PRINCIPALE - Point d'entr√©e Azure Functions
module.exports = async function (context, req) {
    context.log('üöÄ FitGenius - Nouvelle requ√™te re√ßue');

    try {
        const { method } = req;
        
        // Route de test
        if (method === 'GET') {
            context.res = {
                status: 200,
                headers: { 'Content-Type': 'application/json' },
                body: {
                    status: "‚úÖ FitGenius API is running!",
                    version: "1.0.0",
                    endpoints: {
                        whatsapp: "/api/whatsapp",
                        test: "/api/whatsapp?test=true"
                    }
                }
            };
            return;
        }

        // Gestion des messages WhatsApp/SMS
        if (method === 'POST') {
            const { body } = req;
            
            // Test local
            if (req.query.test) {
                const testResponse = await handleTestMessage(body);
                context.res = {
                    status: 200,
                    headers: { 'Content-Type': 'application/json' },
                    body: testResponse
                };
                return;
            }
            
            // Message WhatsApp r√©el (Twilio)
            const { Body, From, MediaUrl0 } = body;
            const phoneNumber = From ? From.replace('whatsapp:', '') : 'test-user';
            
            context.log(`üì± Message de: ${phoneNumber}`);
            context.log(`üí¨ Contenu: ${Body}`);
            context.log(`üì∏ Image: ${MediaUrl0 ? 'Oui' : 'Non'}`);
            
            // Traiter le message
            const response = await processMessage(phoneNumber, Body, MediaUrl0);
            
            // R√©ponse pour Twilio
            context.res = {
                status: 200,
                headers: { 'Content-Type': 'text/xml' },
                body: `<?xml version="1.0" encoding="UTF-8"?>
                       <Response>
                           <Message>${response}</Message>
                       </Response>`
            };
        }
        
    } catch (error) {
        context.log.error('‚ùå Erreur:', error);
        context.res = {
            status: 500,
            body: "D√©sol√©, une erreur s'est produite. R√©essayez!"
        };
    }
};

// Traiter un message
async function processMessage(phoneNumber, text, imageUrl) {
    try {
        console.log("üîç Processing message:", { phoneNumber, text, imageUrl });
        
        // Obtenir ou cr√©er l'utilisateur
        const user = await getOrCreateUser(phoneNumber);
        console.log("üë§ User:", user);
        
        // D√©tecter la langue
        const language = detectLanguage(text);
        console.log("üåê Language:", language);
        
        // Analyser l'intention
        const intent = await analyzeIntent(text, imageUrl, language);
        console.log("üéØ Intention d√©tect√©e:", intent);
        
        // Traiter selon l'intention
        switch(intent.type) {
            case 'SIZE_REQUEST':
                return await handleSizeRequest(user, intent.data, language);
                
            case 'UPDATE_PROFILE':
                return await updateUserProfile(user, intent.data, language);
                
            case 'FEEDBACK':
                return await handleFeedback(user, intent.data, language);
                
            default:
                return getWelcomeMessage(language);
        }
        
    } catch (error) {
        console.error('Erreur processMessage:', error);
        return "D√©sol√©, je n'ai pas pu traiter votre demande. R√©essayez!";
    }
}

// D√©tecter la langue (FR/EN)
function detectLanguage(text) {
    if (!text) return 'auto';
    
    const frenchWords = ['bonjour', 'salut', 'taille', 'quelle', 'pour', 'merci', 'svp', 'chemise', 'pantalon'];
    const textLower = text.toLowerCase();
    
    const hasFrench = frenchWords.some(word => textLower.includes(word));
    return hasFrench ? 'fr' : 'en';
}

// Analyser l'intention avec GPT
async function analyzeIntent(text, imageUrl, language) {
    console.log("üîç D√©but analyse d'intention pour:", text);
    
    const systemPrompt = language === 'fr' 
        ? `Tu analyses les messages pour FitGenius. Identifie l'intention: SIZE_REQUEST (demande de taille), UPDATE_PROFILE (mise √† jour profil), FEEDBACK (retour), OTHER. Pour SIZE_REQUEST, extrais: brand, item_type, url. R√©ponds en JSON.`
        : `You analyze messages for FitGenius. Identify intent: SIZE_REQUEST (size query), UPDATE_PROFILE (profile update), FEEDBACK (feedback), OTHER. For SIZE_REQUEST, extract: brand, item_type, url. Reply in JSON.`;

    try {
        const messages = [
            { role: "system", content: systemPrompt },
            { role: "user", content: text || "Image sent" }
        ];
        
        console.log("ü§ñ Appel OpenAI avec deployment:", process.env.GPT35_DEPLOYMENT_NAME);
        console.log("üìù Messages envoy√©s:", JSON.stringify(messages, null, 2));
        
        const result = await openAIClient.getChatCompletions(
            process.env.GPT35_DEPLOYMENT_NAME,
            messages,
            { temperature: 0.3, maxTokens: 200 }
        );
        
        console.log("‚úÖ R√©sultat complet OpenAI:", result);
        
        const content = result.choices[0].message.content;
        console.log("üìÑ Contenu de la r√©ponse:", content);
        
        const parsed = JSON.parse(content);
        console.log("üìä Intent pars√© avec succ√®s:", parsed);
        
        // REFORMATER pour correspondre √† ce qu'attend le code
        if (parsed.intent === 'SIZE_REQUEST') {
            return {
                type: 'SIZE_REQUEST',
                data: {
                    brand: parsed.brand || 'Gap',
                    item_type: parsed.item_type || 'shirt',
                    size_mentioned: 'M'  // TODO: Am√©liorer la d√©tection
                }
            };
        }
        
        // Autres types d'intent
        return {
            type: parsed.intent || 'OTHER',
            data: {}
        };
        
    } catch (error) {
        console.error('‚ùå Erreur analyse intention:', error);
        console.error('‚ùå Type erreur:', error.constructor.name);
        console.error('‚ùå Message erreur:', error.message);
        console.error('‚ùå Stack:', error.stack);
        
        // FALLBACK - D√©tection manuelle si OpenAI √©choue
        console.log("üîÑ Utilisation du fallback manuel");
        
        if (!text) {
            return { type: 'OTHER' };
        }
        
        const textLower = text.toLowerCase();
        
        // D√©tecter si c'est une demande de taille
        const sizeKeywords = ['shirt', 'chemise', 'pants', 'pantalon', 'dress', 'robe', 'jacket', 'veste', 'size', 'taille', 'medium', 'large', 'small'];
        const brandKeywords = ['gap', 'lululemon', 'roots', 'nike', 'adidas', 'zara', 'h&m'];
        
        const hasSize = sizeKeywords.some(word => textLower.includes(word));
        const hasBrand = brandKeywords.some(word => textLower.includes(word));
        
        if (hasSize || hasBrand) {
            // Extraire la marque
            let brand = 'Gap'; // d√©faut
            for (const b of brandKeywords) {
                if (textLower.includes(b)) {
                    brand = b.charAt(0).toUpperCase() + b.slice(1);
                    break;
                }
            }
            
            // Extraire le type de v√™tement
            let itemType = 'shirt';
            if (textLower.includes('pants') || textLower.includes('pantalon')) itemType = 'pants';
            if (textLower.includes('dress') || textLower.includes('robe')) itemType = 'dress';
            if (textLower.includes('jacket') || textLower.includes('veste')) itemType = 'jacket';
            
            // D√©tecter la taille
            let sizeMentioned = 'M';
            if (textLower.includes(' s ') || textLower.includes('small') || textLower.includes('petit')) sizeMentioned = 'S';
            if (textLower.includes(' m ') || textLower.includes('medium') || textLower.includes('moyen')) sizeMentioned = 'M';
            if (textLower.includes(' l ') || textLower.includes('large') || textLower.includes('grand')) sizeMentioned = 'L';
            
            const fallbackResult = {
                type: 'SIZE_REQUEST',
                data: {
                    brand: brand,
                    item_type: itemType,
                    size_mentioned: sizeMentioned
                }
            };
            
            console.log("‚úÖ R√©sultat fallback:", fallbackResult);
            return fallbackResult;
        }
        
        return { type: 'OTHER' };
    }
}

// G√©rer une demande de taille
async function handleSizeRequest(user, data, language) {
    try {
        console.log("üìè Traitement demande de taille:", data);
        
        // Pour le MVP, on simule une recommandation
        const brands = {
            'gap': { 
                'S': { fr: 'Prenez M - Gap taille petit', en: 'Take M - Gap runs small' },
                'M': { fr: 'Prenez L - Gap taille petit', en: 'Take L - Gap runs small' },
                'L': { fr: 'Prenez XL - Gap taille petit', en: 'Take XL - Gap runs small' }
            },
            'lululemon': { 
                'S': { fr: 'Prenez 4 ou 6', en: 'Take size 4 or 6' },
                'M': { fr: 'Prenez 8 ou 10', en: 'Take size 8 or 10' },
                'L': { fr: 'Prenez 12 ou 14', en: 'Take size 12 or 14' }
            },
            'roots': { 
                'S': { fr: 'Prenez S - Roots taille normalement', en: 'Take S - Roots runs true to size' },
                'M': { fr: 'Prenez M - Roots taille normalement', en: 'Take M - Roots runs true to size' },
                'L': { fr: 'Prenez L - Roots taille normalement', en: 'Take L - Roots runs true to size' }
            }
        };
        
        const brandLower = (data.brand || 'gap').toLowerCase();
        const sizeMentioned = data.size_mentioned || detectSizeInText(data.item_type || '');
        
        console.log("üè∑Ô∏è Marque:", brandLower, "Taille:", sizeMentioned);
        
        const brandRecs = brands[brandLower] || brands['gap'];
        const sizeRec = brandRecs[sizeMentioned] || brandRecs['M'];
        const recommendation = sizeRec[language] || sizeRec['en'];
        
        // Logger l'interaction
        await logInteraction(user, data, recommendation);
        
        // Formater la r√©ponse
        if (language === 'fr') {
            return `üéØ **${data.brand || 'Marque'}**\n\n` +
                   `‚úÖ **Recommandation: ${recommendation}**\n` +
                   `üìä Confiance: 85%\n\n` +
                   `üí° Conseil: ${brandLower === 'gap' ? 'Gap taille g√©n√©ralement petit' : 'V√©rifiez le guide des tailles'}\n\n` +
                   `Cette recommandation vous aide? R√©pondez:\n` +
                   `‚Ä¢ PARFAIT ‚úÖ\n` +
                   `‚Ä¢ TROP GRAND üìè\n` +
                   `‚Ä¢ TROP PETIT üìê`;
        } else {
            return `üéØ **${data.brand || 'Brand'}**\n\n` +
                   `‚úÖ **Recommendation: ${recommendation}**\n` +
                   `üìä Confidence: 85%\n\n` +
                   `üí° Tip: ${brandLower === 'gap' ? 'Gap usually runs small' : 'Check the size guide'}\n\n` +
                   `Was this helpful? Reply:\n` +
                   `‚Ä¢ PERFECT ‚úÖ\n` +
                   `‚Ä¢ TOO BIG üìè\n` +
                   `‚Ä¢ TOO SMALL üìê`;
        }
        
    } catch (error) {
        console.error('Erreur handleSizeRequest:', error);
        return language === 'fr' 
            ? "Je n'ai pas pu analyser ce produit. Envoyez une photo ou un lien!"
            : "I couldn't analyze this product. Send a photo or link!";
    }
}

// D√©tecter la taille mentionn√©e
function detectSizeInText(text) {
    const textUpper = text.toUpperCase();
    if (textUpper.includes('SMALL') || textUpper.includes('PETIT')) return 'S';
    if (textUpper.includes('MEDIUM') || textUpper.includes('MOYEN')) return 'M';
    if (textUpper.includes('LARGE') || textUpper.includes('GRAND')) return 'L';
    if (textUpper.includes(' S ') || textUpper.includes(' S,')) return 'S';
    if (textUpper.includes(' M ') || textUpper.includes(' M,')) return 'M';
    if (textUpper.includes(' L ') || textUpper.includes(' L,')) return 'L';
    return 'M'; // d√©faut
}

// Obtenir ou cr√©er un utilisateur
async function getOrCreateUser(phoneNumber) {
    // VERSION TEMPORAIRE SANS DB
    console.log("üì± User temporaire cr√©√© pour:", phoneNumber);
    return {
        id: phoneNumber,
        phoneNumber: phoneNumber,
        createdAt: new Date().toISOString(),
        measurements: {},
        purchaseHistory: [],
        preferences: {},
        language: 'auto',
        temporary: true
    };
}

// Mettre √† jour le profil utilisateur
async function updateUserProfile(user, data, language) {
    // TEMPORAIRE - Sans DB
    console.log("üìù Mise √† jour profil:", data);
    
    if (language === 'fr') {
        return "‚úÖ Profil mis √† jour! Vos pr√©f√©rences ont √©t√© enregistr√©es.";
    } else {
        return "‚úÖ Profile updated! Your preferences have been saved.";
    }
}

// G√©rer le feedback
async function handleFeedback(user, data, language) {
    // TEMPORAIRE - Sans DB
    console.log("üí¨ Feedback re√ßu:", data);
    
    if (language === 'fr') {
        return "Merci pour votre retour! Cela nous aide √† am√©liorer nos recommandations. üôè";
    } else {
        return "Thanks for your feedback! This helps us improve our recommendations. üôè";
    }
}

// Logger une interaction
async function logInteraction(user, data, recommendation) {
    // TEMPORAIREMENT D√âSACTIV√â
    console.log("üìä Interaction:", { user: user.id, data, recommendation });
    return;
}

// Messages de bienvenue bilingues
function getWelcomeMessage(language = 'auto') {
    const messages = {
        fr: `üëã Bienvenue sur FitGenius!\n\n` +
            `Je suis votre assistant taille personnel ü§ñ\n\n` +
            `Envoyez-moi:\n` +
            `üì∏ Une photo d'un v√™tement\n` +
            `üîó Un lien de produit\n` +
            `‚úèÔ∏è Ou √©crivez "Gap chemise medium"\n\n` +
            `Je vous dirai quelle taille commander! üéØ`,
        
        en: `üëã Welcome to FitGenius!\n\n` +
            `I'm your personal size assistant ü§ñ\n\n` +
            `Send me:\n` +
            `üì∏ A photo of any clothing\n` +
            `üîó A product link\n` +
            `‚úèÔ∏è Or type "Gap shirt medium"\n\n` +
            `I'll tell you which size to order! üéØ`,
            
        auto: `üëã Welcome to FitGenius! / Bienvenue!\n\n` +
              `üá®üá¶ I'm your personal size assistant\n` +
              `üá®üá¶ Je suis votre assistant taille\n\n` +
              `Send me / Envoyez-moi:\n` +
              `üì∏ A photo / Une photo\n` +
              `üîó A link / Un lien\n` +
              `‚úèÔ∏è Or type / Ou √©crivez\n\n` +
              `I'll find your size! / Je trouve votre taille! üéØ`
    };
    
    return messages[language] || messages.auto;
}

// G√©rer les tests locaux
async function handleTestMessage(body) {
    const { message, phoneNumber = 'test-user' } = body;
    const response = await processMessage(phoneNumber, message, null);
    
    return {
        request: body,
        response: response,
        timestamp: new Date().toISOString()
    };

}
